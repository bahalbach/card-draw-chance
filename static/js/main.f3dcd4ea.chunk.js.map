{"version":3,"sources":["App/Header.tsx","App/NumberInput.tsx","App/hypergeometric.ts","App/CardDrawChance.tsx","App/App.tsx","theme.ts","index.tsx"],"names":["Header","Box","sx","flexGrow","AppBar","position","Toolbar","Typography","variant","component","NumberInput","label","value","onChange","TextField","margin","fullWidth","type","inputProps","inputMode","pattern","min","hyp","successesObserved","sampled","successesAvailable","popSize","smallerSet","largerSet","h","s","k","i","CardDrawChance","React","deckSize","setDeckSize","drawSize","setDrawSize","lookFor","setLookFor","chances","setChances","rows","map","chance","index","TableRow","TableCell","scope","align","Math","round","display","flexDirection","alignItems","my","onSubmit","e","preventDefault","deck","Number","draw","target","isInteger","validateNumbers","lastChance","push","mt","event","Button","mb","Table","TableHead","TableBody","Copyright","color","Link","href","Date","getFullYear","App","Container","maxWidth","theme","createTheme","palette","primary","main","secondary","error","red","A400","ReactDOM","render","ThemeProvider","CssBaseline","document","querySelector"],"mappings":"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","file":"static/js/main.f3dcd4ea.chunk.js","sourcesContent":["import * as React from \"react\";\r\nimport AppBar from \"@mui/material/AppBar\";\r\nimport Box from \"@mui/material/Box\";\r\nimport Toolbar from \"@mui/material/Toolbar\";\r\nimport Typography from \"@mui/material/Typography\";\r\n\r\nexport default function Header() {\r\n  return (\r\n    <Box sx={{ flexGrow: 1 }}>\r\n      <AppBar position=\"static\">\r\n        <Toolbar>\r\n          <Typography variant=\"h6\" component=\"div\">\r\n            Card Draw Chance\r\n          </Typography>\r\n        </Toolbar>\r\n      </AppBar>\r\n    </Box>\r\n  );\r\n}\r\n","import * as React from \"react\";\r\nimport TextField from \"@mui/material/TextField\";\r\n\r\ntype PropsType = {\r\n  label: string;\r\n  value: string;\r\n  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;\r\n};\r\nexport default function NumberInput({ label, value, onChange }: PropsType) {\r\n  return (\r\n    <TextField\r\n      margin=\"normal\"\r\n      fullWidth\r\n      label={label}\r\n      value={value}\r\n      onChange={onChange}\r\n      type=\"number\"\r\n      inputProps={{ inputMode: \"numeric\", pattern: \"[0-9]*\", min: 0 }}\r\n    />\r\n  );\r\n}\r\n","// Hypergeometric JS from http://www.math.ucla.edu/~tom/distributions/Hypergeometric.html\r\n// See <https://gist.github.com/trevnorris/c39ac96740842e05303f>\r\n// Annotated by Adam Novak\r\n// Taken from: https://gist.github.com/adamnovak/f34e6cf2c08684752a9d\r\n// Ben Halbach: I changed to output 1 when sampled == 0 or successesAvailable == 0, line 17\r\n\r\nexport default function hypergeometricCDF(\r\n  successesObserved: number,\r\n  sampled: number,\r\n  successesAvailable: number,\r\n  popSize: number\r\n) {\r\n  let Prob = 0;\r\n  if (sampled <= 0 || successesAvailable <= 0 || popSize <= 0) {\r\n    // Nothing sampled or no successes available or nothing in the\r\n    // population.\r\n    Prob = 1;\r\n  } else if (successesAvailable > popSize || sampled > popSize) {\r\n    // Successes available or samples taken larger than actual population.\r\n\r\n    Prob = 0;\r\n  } else if (\r\n    successesObserved < 0 ||\r\n    successesObserved < sampled + successesAvailable - popSize\r\n  ) {\r\n    // We observed negative successes, or we pulled out so much of the\r\n    // population that we would absolutely have had to have sampled more\r\n    // succeses than this.\r\n    Prob = 0;\r\n  } else if (\r\n    successesObserved >= sampled ||\r\n    successesObserved >= successesAvailable\r\n  ) {\r\n    // We saw as many successes as we had samples (or even more), or we saw\r\n    // all (or more) of the successes available. The probability of seeing\r\n    // that many successes *or fewer* is thus 1.\r\n    Prob = 1;\r\n  } else {\r\n    // We can't short-circuit and get the answer already. We have to do real\r\n    // math. But first, we have to precondition the input parameters to the\r\n    // CDF function.\r\n\r\n    if (2 * successesAvailable > popSize) {\r\n      // More than half of the population is successes.\r\n\r\n      if (2 * sampled > popSize) {\r\n        // More than half the population has been sampled.\r\n\r\n        // Change to a different problem:\r\n\r\n        // Out of the same size population, with success and failure\r\n        // reversed, sampling everything we didn't sample before, what's\r\n        // the probability we sample that many or more of the things\r\n        // that were originally unsampled failures?\r\n\r\n        // The popSize - successesAvailable - sampled +\r\n        // successesObserved has the +successesObserved to avoid double-\r\n        // counting the successesAvailable that were also sampled in the\r\n        // subtraction. So it gets the number of things that were\r\n        // originally neither sampled nor observed.\r\n\r\n        // P(the unsampled part contains some number of failures or\r\n        // fewer) = P(the sampled part contains x successes or fewer)\r\n\r\n        Prob = hyp(\r\n          popSize - successesAvailable - sampled + successesObserved,\r\n          popSize - sampled,\r\n          popSize - successesAvailable,\r\n          popSize\r\n        );\r\n      } else {\r\n        // Half or less of the population has been sampled.\r\n\r\n        // Change to a different different problem:\r\n\r\n        // Out of the same size population, with success and failure\r\n        // reversed, sampling the same number of things, what's the\r\n        // probability of observing the same situation we actually\r\n        // observed, but with success and failure reversed? Or something\r\n        // with more successes than that?\r\n\r\n        // Basically we go and get the other (smaller) tail, and do 1\r\n        // minus that.\r\n\r\n        Prob =\r\n          1 -\r\n          hyp(\r\n            sampled - successesObserved - 1,\r\n            sampled,\r\n            popSize - successesAvailable,\r\n            popSize\r\n          );\r\n      }\r\n    } else if (2 * sampled > popSize) {\r\n      // Half or less of the population is successes, but we sampled more\r\n      // than half of it.\r\n\r\n      // Try a different problem: sample the part we didn't sample before,\r\n      // and look at the probability of finding the corresponding number\r\n      // of successes or more in that part, and then flip around to the\r\n      // other tail.\r\n\r\n      Prob =\r\n        1 -\r\n        hyp(\r\n          successesAvailable - successesObserved - 1,\r\n          successesAvailable,\r\n          popSize - sampled,\r\n          popSize\r\n        );\r\n    } else {\r\n      // We're sampling half or less of the population, and half or less\r\n      // of it is successes. Just go straight to the actual function.\r\n      Prob = hyp(successesObserved, sampled, successesAvailable, popSize);\r\n    }\r\n  }\r\n  return Prob;\r\n}\r\n\r\n//enter with successesAvailable<popSize/2 and sampled<popSize/2\r\nfunction hyp(\r\n  successesObserved: number,\r\n  sampled: number,\r\n  successesAvailable: number,\r\n  popSize: number\r\n) {\r\n  // The actual hypergeometric CDF. Requires that half or less of the\r\n  // population be successes, and that half or less of the population be\r\n  // sampled.\r\n\r\n  // We conceptualize the problem like this: given the population, choose the\r\n  // successes, choose the sampled items, and look at the size of the overlap.\r\n\r\n  // Because of this, it doesn't matter which set is the successes and which\r\n  // is the sampled items, so we can swap those around for numerical reasons.\r\n\r\n  // What are the sizes of the two sets we are intersecting, identifgied by\r\n  // relative size?\r\n  var smallerSet, largerSet;\r\n\r\n  // best to have sampled<successesAvailable\r\n  if (successesAvailable < sampled) {\r\n    // The set of successes is smaller\r\n    smallerSet = successesAvailable;\r\n    largerSet = sampled;\r\n  } else {\r\n    // The set of sampled items is smaller\r\n    smallerSet = sampled;\r\n    largerSet = successesAvailable;\r\n  }\r\n\r\n  // This is an intermediate value I don't really understand, which is used in\r\n  // the middle of the cumulative CDF calculation.\r\n  var h = 1;\r\n\r\n  // This is the probability of having observed everything we looked at so\r\n  // far. Except sometimes it goes above 1 and we have to fix it?\r\n  var s = 1;\r\n\r\n  // This is an index over which item we are at in the smaller set\r\n  var k = 0;\r\n\r\n  // This is an index over which item we are at in the intersection\r\n  var i = 0;\r\n\r\n  while (i < successesObserved) {\r\n    // For each item in the intersection\r\n\r\n    while (s > 1 && k < smallerSet) {\r\n      // Sample some items from the smaller set (?)\r\n\r\n      // Get the probability of, after already grabbing k items for the\r\n      // smaller set that weren't in the larger set, grabbing another\r\n      // item for the smaller set that wasn't in the larger set.\r\n\r\n      // Then multiply h and s by this probability\r\n\r\n      h = h * (1 - largerSet / (popSize - k));\r\n      s = s * (1 - largerSet / (popSize - k));\r\n\r\n      // Advance to the next item in the smaller set.\r\n      k = k + 1;\r\n    }\r\n\r\n    // Get the number of things not taken for the intersection, after taking\r\n    // this thing: (popSize - smallerSet - largerSet + i + 1)\r\n\r\n    // Get the number of things in the smaller set not in the intersection,\r\n    // and multiply by the number of things in the larger set not in the\r\n    // intersection.\r\n\r\n    // As i goes from 0 to successesObserved, h accumulates:\r\n    // factors of smallerSet to smallerSet - successesObserved on top\r\n    // factors of largerSet to largerSet - successesObserved on top\r\n    // factors of 1 to successesObserved on bottom\r\n    // factors of (popSize - smallerSet - largerSet + 1) to\r\n    //    (popSize - smallerSet - largerSet + successesObserved)\r\n\r\n    // I'm not entirely sure how this works, but it looks like we're\r\n    // cheating a bit to calculate the sum of ratios of factorials without\r\n    // needing to re-do lots of the multiplications.\r\n\r\n    h =\r\n      (h * (smallerSet - i) * (largerSet - i)) /\r\n      (i + 1) /\r\n      (popSize - smallerSet - largerSet + i + 1);\r\n    s = s + h;\r\n\r\n    // Move on to the next item in the intersection\r\n    i = i + 1;\r\n  }\r\n\r\n  while (k < smallerSet) {\r\n    // For each remaining item in the smaller set (conceptually the sampled\r\n    // ones) that was not part of the intersection(?)\r\n\r\n    // popSize - k is the number of items remaining to be grabbed for the\r\n    // smaller set.\r\n\r\n    // largerSet / (popSize - k) is the probability that the next item\r\n    // grabbed for the smaller set would be in the larger set.\r\n\r\n    // We take 1 - that because we know the next item grabbed for the\r\n    // smaller set will not have been in the larger set, since it wasn't in\r\n    // the intersection.\r\n\r\n    // Then we multiply the probability of everything we've seen so far by\r\n    // the probability of having successfully not added some extra thing to\r\n    // our intersection.\r\n    s = s * (1 - largerSet / (popSize - k));\r\n\r\n    // Move on to grab the next item in the smaller set.\r\n    k = k + 1;\r\n  }\r\n\r\n  return s;\r\n}\r\n","import * as React from \"react\";\r\nimport Box from \"@mui/material/Box\";\r\nimport NumberInput from \"./NumberInput\";\r\nimport Button from \"@mui/material/Button\";\r\nimport List from \"@mui/material/List\";\r\nimport Table from \"@mui/material/Table\";\r\nimport TableBody from \"@mui/material/TableBody\";\r\nimport TableCell from \"@mui/material/TableCell\";\r\nimport TableContainer from \"@mui/material/TableContainer\";\r\nimport TableHead from \"@mui/material/TableHead\";\r\nimport TableRow from \"@mui/material/TableRow\";\r\nimport Paper from \"@mui/material/Paper\";\r\nimport hypergeometricCDF from \"./hypergeometric\";\r\n\r\nexport default function CardDrawChance() {\r\n  const [deckSize, setDeckSize] = React.useState(\"60\");\r\n  const handleDeckSizeChange = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n    setDeckSize(event.target.value);\r\n  };\r\n  const [drawSize, setDrawSize] = React.useState(\"7\");\r\n  const handleDrawSizeChange = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n    setDrawSize(event.target.value);\r\n  };\r\n  const [lookFor, setLookFor] = React.useState(\"4\");\r\n  const handleLookForChange = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n    setLookFor(event.target.value);\r\n  };\r\n  const [chances, setChances] = React.useState([1]);\r\n\r\n  const validateNumbers = (deck: number, draw: number, target: number) => {\r\n    if (\r\n      !Number.isInteger(deck) ||\r\n      !Number.isInteger(draw) ||\r\n      !Number.isInteger(target)\r\n    ) {\r\n      return false;\r\n    }\r\n    if (target < 0 || draw < 0 || deck < draw) {\r\n      return false;\r\n    }\r\n    return true;\r\n  };\r\n\r\n  const calculateChances = (e: React.FormEvent<HTMLFormElement>) => {\r\n    e.preventDefault();\r\n    const deck = Number(deckSize);\r\n    const draw = Number(drawSize);\r\n    const target = Number(lookFor);\r\n    if (!validateNumbers(deck, draw, target)) {\r\n      return;\r\n    }\r\n    const chances = [];\r\n    let lastChance = 0;\r\n    for (let i = 0; i <= Math.min(target, draw); i++) {\r\n      // calculate the chance to see <= i of target type\r\n      const chance = hypergeometricCDF(i, draw, target, deck);\r\n      chances.push(chance - lastChance);\r\n      lastChance = chance;\r\n    }\r\n    setChances(chances);\r\n  };\r\n\r\n  const rows = chances.map((chance: number, index: number) => {\r\n    return (\r\n      <TableRow key={index}>\r\n        <TableCell component=\"th\" scope=\"row\">\r\n          {index}\r\n        </TableCell>\r\n        <TableCell align=\"right\">{Math.round(chance * 100)}%</TableCell>\r\n      </TableRow>\r\n    );\r\n  });\r\n\r\n  return (\r\n    <Box\r\n      sx={{\r\n        display: \"flex\",\r\n        flexDirection: \"column\",\r\n        alignItems: \"center\",\r\n        my: 2,\r\n      }}\r\n    >\r\n      <Box component=\"form\" onSubmit={calculateChances} sx={{ mt: 0 }}>\r\n        <NumberInput\r\n          label=\"# of Cards in Deck\"\r\n          value={deckSize}\r\n          onChange={handleDeckSizeChange}\r\n        />\r\n        <NumberInput\r\n          label=\"# of Cards to Draw\"\r\n          value={drawSize}\r\n          onChange={handleDrawSizeChange}\r\n        />\r\n        <NumberInput\r\n          label=\"# of Cards to Look For\"\r\n          value={lookFor}\r\n          onChange={handleLookForChange}\r\n        />\r\n        <Button\r\n          type=\"submit\"\r\n          fullWidth\r\n          variant=\"contained\"\r\n          sx={{ mt: 2, mb: 2 }}\r\n        >\r\n          Calculate Chance\r\n        </Button>\r\n      </Box>\r\n      <Table>\r\n        <TableHead>\r\n          <TableRow>\r\n            <TableCell># Drawn</TableCell>\r\n            <TableCell align=\"right\">Chance</TableCell>\r\n          </TableRow>\r\n        </TableHead>\r\n        <TableBody>{rows}</TableBody>\r\n      </Table>\r\n    </Box>\r\n  );\r\n}\r\n","import * as React from \"react\";\nimport Container from \"@mui/material/Container\";\nimport Typography from \"@mui/material/Typography\";\nimport Box from \"@mui/material/Box\";\nimport Link from \"@mui/material/Link\";\nimport ProTip from \"./ProTip\";\nimport Header from \"./Header\";\nimport CardDrawChance from \"./CardDrawChance\";\n\nfunction Copyright() {\n  return (\n    <Typography variant=\"body2\" color=\"text.secondary\" align=\"center\">\n      {\"Copyright © \"}\n      <Link color=\"inherit\" href=\"https://www.benhalbach.com/\">\n        Ben Halbach\n      </Link>{\" \"}\n      {new Date().getFullYear()}.\n    </Typography>\n  );\n}\n\nexport default function App() {\n  return (\n    <React.Fragment>\n      <Header />\n      <Container maxWidth=\"sm\">\n        <Box sx={{ my: 2 }}>\n          <CardDrawChance />\n          <Copyright />\n        </Box>\n      </Container>\n    </React.Fragment>\n  );\n}\n","import { createTheme } from '@mui/material/styles';\nimport { red } from '@mui/material/colors';\n\n// A custom theme for this app\nconst theme = createTheme({\n  palette: {\n    primary: {\n      main: '#556cd6',\n    },\n    secondary: {\n      main: '#19857b',\n    },\n    error: {\n      main: red.A400,\n    },\n  },\n});\n\nexport default theme;\n","import * as React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport CssBaseline from \"@mui/material/CssBaseline\";\nimport { ThemeProvider } from \"@mui/material/styles\";\nimport App from \"./App/App\";\nimport theme from \"./theme\";\n\nReactDOM.render(\n  <ThemeProvider theme={theme}>\n    {/* CssBaseline kickstart an elegant, consistent, and simple baseline to build upon. */}\n    <CssBaseline />\n    <App />\n  </ThemeProvider>,\n  document.querySelector(\"#root\")\n);\n"],"sourceRoot":""}